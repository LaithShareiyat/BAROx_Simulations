"""
Torque Vectoring System Model.

This module implements torque vectoring (TV) for electric vehicles with
independent motors per wheel. TV creates a yaw moment by applying
differential torque to left and right wheels.

Physics:
    Yaw moment from differential torque:
        M_z = ΔF_x × (track_width / 2)
        M_z = (F_x_outer - F_x_inner) × (t / 2)

    Where:
        ΔF_x = difference in longitudinal force
        t = track width [m]
        F_x_outer = force on outer wheel (more loaded in corner)
        F_x_inner = force on inner wheel (less loaded)

Strategies:
    1. Load Proportional: Distribute torque proportional to vertical load
    2. Fixed Bias: Apply fixed percentage more to outer wheel
    3. Yaw Rate Based: Use yaw rate error feedback (not implemented in QSS)

Benefits:
    - Reduces understeer by adding yaw moment into corner
    - Better traction by using available grip on each wheel
    - Improved corner exit acceleration
"""

import numpy as np
from dataclasses import dataclass
from models.vehicle import VehicleParams, TorqueVectoringParams
from physics.weight_transfer import calculate_wheel_loads, WheelLoads


@dataclass
class TorqueVectoringOutput:
    """Output of torque vectoring calculations."""
    M_z: float               # Yaw moment [Nm] (positive = turn left)
    torque_split: dict       # Torque ratio per wheel {'FL': 0.25, ...}
    F_x_per_wheel: dict      # Longitudinal force per wheel [N]
    effectiveness_used: float  # Actual effectiveness applied [0-1]
    limited: bool            # True if grip-limited


def calculate_tv_yaw_moment(vehicle: VehicleParams,
                            a_y: float,
                            a_x: float = 0.0,
                            F_x_total: float = 0.0) -> TorqueVectoringOutput:
    """
    Calculate the yaw moment generated by torque vectoring.

    In cornering, torque vectoring shifts drive torque from the inside
    (less loaded) wheels to the outside (more loaded) wheels. This:
    1. Creates a yaw moment that helps turn the car
    2. Better utilises available grip at each wheel

    Args:
        vehicle: Vehicle parameters with torque vectoring config
        a_y: Lateral acceleration [m/s²] (positive = turning right)
        a_x: Longitudinal acceleration [m/s²] (positive = accelerating)
        F_x_total: Total longitudinal force demand [N]

    Returns:
        TorqueVectoringOutput with yaw moment and torque distribution
    """
    # Check if TV is available
    if not vehicle.has_torque_vectoring:
        return TorqueVectoringOutput(
            M_z=0.0,
            torque_split={'FL': 0.25, 'FR': 0.25, 'RL': 0.25, 'RR': 0.25},
            F_x_per_wheel={'FL': 0.0, 'FR': 0.0, 'RL': 0.0, 'RR': 0.0},
            effectiveness_used=0.0,
            limited=False,
        )

    tv = vehicle.torque_vectoring
    mu = vehicle.mu

    # Get geometry
    if vehicle.geometry is not None:
        t_r = vehicle.geometry.track_rear_m
        t_f = vehicle.geometry.track_front_m
    else:
        t_r = 1.20
        t_f = 1.20

    # Calculate wheel loads
    loads = calculate_wheel_loads(vehicle, a_x, a_y)

    # Determine driven wheels based on drivetrain
    drivetrain = vehicle.powertrain.drivetrain if vehicle.has_extended_powertrain else '2RWD'

    # Check if single motor (TV not available with mechanical differential)
    is_single_motor = drivetrain.startswith('1')
    if is_single_motor:
        # Single motor configs can't do torque vectoring
        return TorqueVectoringOutput(
            M_z=0.0,
            torque_split={'FL': 0.0, 'FR': 0.0, 'RL': 0.5, 'RR': 0.5} if 'RWD' in drivetrain else {'FL': 0.5, 'FR': 0.5, 'RL': 0.0, 'RR': 0.0},
            F_x_per_wheel={'FL': 0.0, 'FR': 0.0, 'RL': 0.0, 'RR': 0.0},
            effectiveness_used=0.0,
            limited=False,
        )

    if drivetrain in ('FWD', '2FWD', '1FWD'):
        driven_wheels = ['FL', 'FR']
        track = t_f
    elif drivetrain in ('RWD', '2RWD', '1RWD'):
        driven_wheels = ['RL', 'RR']
        track = t_r
    else:  # AWD
        driven_wheels = ['FL', 'FR', 'RL', 'RR']
        track = (t_f + t_r) / 2  # Average for AWD

    # Calculate torque distribution based on strategy
    if tv.strategy == 'load_proportional':
        output = _load_proportional_split(
            vehicle, loads, driven_wheels, track, a_y, F_x_total, tv
        )
    elif tv.strategy == 'fixed_bias':
        output = _fixed_bias_split(
            vehicle, loads, driven_wheels, track, a_y, F_x_total, tv
        )
    else:
        # Default to load proportional
        output = _load_proportional_split(
            vehicle, loads, driven_wheels, track, a_y, F_x_total, tv
        )

    return output


def _load_proportional_split(vehicle: VehicleParams,
                              loads: WheelLoads,
                              driven_wheels: list,
                              track: float,
                              a_y: float,
                              F_x_total: float,
                              tv: TorqueVectoringParams) -> TorqueVectoringOutput:
    """
    Distribute torque proportional to vertical load.

    This maximises traction by ensuring each wheel operates at the
    same grip utilisation level.
    """
    mu = vehicle.mu
    loads_dict = loads.as_dict()

    # Total vertical load on driven wheels
    F_z_driven = sum(loads_dict[w] for w in driven_wheels)

    if F_z_driven < 1.0:  # Avoid division by zero
        return TorqueVectoringOutput(
            M_z=0.0,
            torque_split={w: 1.0/len(driven_wheels) for w in driven_wheels},
            F_x_per_wheel={w: 0.0 for w in ['FL', 'FR', 'RL', 'RR']},
            effectiveness_used=0.0,
            limited=False,
        )

    # Ideal split: proportional to vertical load
    ideal_split = {w: loads_dict[w] / F_z_driven for w in driven_wheels}

    # Calculate deviation from equal split
    equal_split = 1.0 / len(driven_wheels)
    max_deviation = tv.max_torque_transfer

    # Apply transfer limit
    torque_split = {}
    for w in driven_wheels:
        deviation = ideal_split[w] - equal_split
        limited_deviation = np.clip(deviation, -max_deviation, max_deviation)
        torque_split[w] = equal_split + limited_deviation * tv.effectiveness

    # Normalise to sum to 1.0
    total_split = sum(torque_split.values())
    torque_split = {w: s / total_split for w, s in torque_split.items()}

    # Calculate forces per wheel
    F_x_per_wheel = {w: F_x_total * torque_split.get(w, 0.0) for w in ['FL', 'FR', 'RL', 'RR']}

    # Check grip limits
    limited = False
    for w in driven_wheels:
        F_x_max = mu * loads_dict[w]
        if abs(F_x_per_wheel[w]) > F_x_max:
            limited = True
            break

    # Calculate yaw moment
    # For RWD: M_z = (F_x_RL - F_x_RR) × (t/2) for right turn (a_y > 0)
    # Outer wheel (RL in right turn) gets more torque
    if a_y >= 0:  # Right turn
        if 'RL' in driven_wheels and 'RR' in driven_wheels:
            M_z = (F_x_per_wheel['RL'] - F_x_per_wheel['RR']) * (track / 2)
        elif 'FL' in driven_wheels and 'FR' in driven_wheels:
            M_z = (F_x_per_wheel['FL'] - F_x_per_wheel['FR']) * (track / 2)
        else:
            M_z = 0.0
    else:  # Left turn
        if 'RL' in driven_wheels and 'RR' in driven_wheels:
            M_z = (F_x_per_wheel['RR'] - F_x_per_wheel['RL']) * (track / 2)
        elif 'FL' in driven_wheels and 'FR' in driven_wheels:
            M_z = (F_x_per_wheel['FR'] - F_x_per_wheel['FL']) * (track / 2)
        else:
            M_z = 0.0

    return TorqueVectoringOutput(
        M_z=M_z,
        torque_split=torque_split,
        F_x_per_wheel=F_x_per_wheel,
        effectiveness_used=tv.effectiveness,
        limited=limited,
    )


def _fixed_bias_split(vehicle: VehicleParams,
                       loads: WheelLoads,
                       driven_wheels: list,
                       track: float,
                       a_y: float,
                       F_x_total: float,
                       tv: TorqueVectoringParams) -> TorqueVectoringOutput:
    """
    Apply fixed bias to outer wheels in corners.

    Simpler strategy that applies a fixed percentage more torque
    to the outer wheels regardless of load transfer.
    """
    mu = vehicle.mu
    loads_dict = loads.as_dict()

    bias = tv.max_torque_transfer * tv.effectiveness

    # Determine inner/outer wheels
    if a_y >= 0:  # Right turn - left wheels are outer
        outer_rear, inner_rear = 'RL', 'RR'
        outer_front, inner_front = 'FL', 'FR'
    else:  # Left turn - right wheels are outer
        outer_rear, inner_rear = 'RR', 'RL'
        outer_front, inner_front = 'FR', 'FL'

    # Calculate split with bias
    torque_split = {}
    if len(driven_wheels) == 2:  # FWD or RWD
        if 'RL' in driven_wheels:  # RWD
            torque_split[outer_rear] = 0.5 + bias / 2
            torque_split[inner_rear] = 0.5 - bias / 2
        else:  # FWD
            torque_split[outer_front] = 0.5 + bias / 2
            torque_split[inner_front] = 0.5 - bias / 2
    else:  # AWD
        # Split between front and rear, then apply bias
        torque_split[outer_rear] = 0.25 + bias / 4
        torque_split[inner_rear] = 0.25 - bias / 4
        torque_split[outer_front] = 0.25 + bias / 4
        torque_split[inner_front] = 0.25 - bias / 4

    # Calculate forces
    F_x_per_wheel = {w: F_x_total * torque_split.get(w, 0.0) for w in ['FL', 'FR', 'RL', 'RR']}

    # Check grip limits
    limited = False
    for w in driven_wheels:
        F_x_max = mu * loads_dict[w]
        if abs(F_x_per_wheel[w]) > F_x_max:
            limited = True
            break

    # Calculate yaw moment
    if 'RL' in driven_wheels:
        M_z = (F_x_per_wheel[outer_rear] - F_x_per_wheel[inner_rear]) * (track / 2)
    else:
        M_z = (F_x_per_wheel[outer_front] - F_x_per_wheel[inner_front]) * (track / 2)

    return TorqueVectoringOutput(
        M_z=M_z,
        torque_split=torque_split,
        F_x_per_wheel=F_x_per_wheel,
        effectiveness_used=tv.effectiveness,
        limited=limited,
    )


def calculate_tv_lateral_benefit(vehicle: VehicleParams,
                                  a_y: float,
                                  a_x: float = 0.0) -> float:
    """
    Calculate the effective lateral grip improvement from torque vectoring.

    The TV yaw moment allows higher cornering speeds by:
    1. Reducing required tire slip angles
    2. Providing additional yaw moment that supplements tire lateral forces

    Args:
        vehicle: Vehicle parameters
        a_y: Current lateral acceleration [m/s²]
        a_x: Current longitudinal acceleration [m/s²]

    Returns:
        Effective friction coefficient multiplier (1.0 = no improvement)
    """
    if not vehicle.has_torque_vectoring:
        return 1.0

    tv = vehicle.torque_vectoring
    mu = vehicle.mu
    g = vehicle.g

    # Calculate TV yaw moment at this condition
    tv_output = calculate_tv_yaw_moment(vehicle, a_y, a_x, F_x_total=0.0)

    # The yaw moment can be "converted" to equivalent lateral force
    # This is a simplified model - actual benefit depends on vehicle balance
    if vehicle.geometry is not None:
        L_r = vehicle.geometry.L_r_m
    else:
        L_r = 0.80

    # Equivalent lateral force from yaw moment
    # M_z = F_y × L_r  →  F_y = M_z / L_r
    F_y_equivalent = abs(tv_output.M_z) / L_r

    # Weight on rear axle
    F_z_rear = vehicle.m * g * 0.5  # Approximate

    # Improvement in effective μ
    delta_mu = F_y_equivalent / F_z_rear if F_z_rear > 0 else 0.0

    # Apply effectiveness and cap improvement
    improvement = 1.0 + delta_mu * tv.effectiveness

    # Cap at reasonable maximum (15% improvement typical)
    max_improvement = 1.15
    improvement = min(improvement, max_improvement)

    return improvement


def calculate_tv_traction_benefit(vehicle: VehicleParams,
                                   a_y: float,
                                   a_x: float) -> float:
    """
    Calculate the traction improvement from torque vectoring.

    By distributing torque proportional to wheel load, TV allows
    better utilisation of available grip at each wheel.

    Args:
        vehicle: Vehicle parameters
        a_y: Lateral acceleration [m/s²]
        a_x: Longitudinal acceleration [m/s²]

    Returns:
        Traction force multiplier (1.0 = no improvement)
    """
    if not vehicle.has_torque_vectoring:
        return 1.0

    tv = vehicle.torque_vectoring
    mu = vehicle.mu

    # Calculate wheel loads
    loads = calculate_wheel_loads(vehicle, a_x, a_y)

    # Determine driven wheels
    drivetrain = vehicle.powertrain.drivetrain if vehicle.has_extended_powertrain else '2RWD'

    # Single motor configs can't benefit from TV traction improvement
    if drivetrain.startswith('1'):
        return 1.0

    if drivetrain in ('FWD', '2FWD'):
        driven = ['FL', 'FR']
    elif drivetrain in ('RWD', '2RWD'):
        driven = ['RL', 'RR']
    else:  # AWD
        driven = ['FL', 'FR', 'RL', 'RR']

    loads_dict = loads.as_dict()

    # Without TV: limited by lowest-loaded wheel
    F_z_min = min(loads_dict[w] for w in driven)
    F_x_without_tv = mu * F_z_min * len(driven)

    # With TV: can use all available grip
    F_x_with_tv = sum(mu * loads_dict[w] for w in driven)

    # Improvement ratio
    if F_x_without_tv > 0:
        improvement = F_x_with_tv / F_x_without_tv
    else:
        improvement = 1.0

    # Apply effectiveness
    improvement = 1.0 + (improvement - 1.0) * tv.effectiveness

    return improvement
